{-
 - add :: Nat -> Nat -> Nat
 - add Zero m = m
 - add (Succ n) m = Succ (add n m)
 -
 - 1) Show that
 -    add n (Succ m) = Succ (add n m)
 -    SOL: In the base case:
 -      add Zero (Succ m) = Succ m
 -                     = Succ (add Zero m) \\ def. of add
 -    Now supposing that for some n>0, we know
 -    add n (Succ m) = Succ (add n m):
 -      add (Succ n) (Succ m) = Succ (add n (Succ m)) \\ def. of add
 -                            = Succ (Succ (add n m)) \\ ind. hypothesis
 -                            = Succ (add (Succ n) m) \\ def. of add
 - 2) Using (1) along with the fact that add n Zero = n,
 -    show that addition is commutative
 -    SOL: In the base case:
 -      add Zero m = m \\ def. of add
 -                 = add m Zero \\ given fact
 -    In the inductive case:
 -      add (Succ n) m = Succ (add n m) \\ def. of add
 -                     = add n (Succ m) \\ problem (1)
 -                     = add (Succ m) n \\ ind. hypothesis
 -                     = Succ (add m n) \\ def. of add
 -                     = add m (Succ n) \\ problem (1)
 -
 - 3) Consider the definition:
 -   all p []     = True 
 -   all p (x:xs) = p x && all p xs
 -    Prove that replicate produces a list with identical elements
 -    That is, all (==x) (replicate n x) = True
 -    SOL: In the base case:
 -    all (==x) (replicate 0 x) = all (==x) [] \\ def. of replicate
 -                              = True         \\ def. of all
 -    In the inductive case:
 -    all (==x) (replicate (Succ n) x) 
 -            = all (==x) (x : replicate n x) \\ def. of replicate
 -            = (==x) x && all (==x) (replicate n x) \\ def. of all
 -            = True && True \\ def. of (==x) plus ind. hypothesis
 -            = True
 -
 - 4) Use the definition
 -    []     ++ ys = ys
 -    (x:xs) ++ ys = x : (xs ++ ys)
 -    verify that:
 -    a) xs ++ [] = xs
 -    b) xs ++ (ys ++ zs) = (xs ++ ys) ++ zs
 -    SOL: For (a), we start with the base case:
 -      [] ++ [] = [] \\ def of ++
 -    Inductively, we have
 -      (x:xs) ++ [] = x : (xs ++ []) \\ def of ++
 -                   = x : xs \\ ind hypothesis
 -                   = (x:xs)
 -    For (b), we start with the base case:
 -      [] ++ (ys ++ zs) = ys ++ zs \\ def of ++
 -                       = ([] ++ ys) ++ zs \\ def of ++
 -    Inductively, we have
 -      (x:xs) ++ (ys ++ zs) = x : (xs ++ (ys ++ zs)) \\ def of ++
 -                           = x : ((xs ++ ys) ++ zs) \\ ind hypothesis
 -                           = (x: (xs ++ ys)) ++ zs \\ def of ++
 -                           = ((x:xs) ++ ys) ++ zs \\ def of ++
 -
 - 5) Use the following defintions
 -    take 0 _      = []
 -    take _ []     = []
 -    take n (x:xs) = x : take (n-1) xs
 -    and
 -    drop 0 xs     = xs
 -    drop _ []     = []
 -    drop n (_:xs) = drop (n-1) xs
 -    show that take n xs ++ drop n xs = xs
 -    SOL: In the case n=0:
 -    take 0 xs ++ drop 0 xs = [] ++ xs \\ def's
 -                           = xs \\ def of ++ 
 -    In the case xs = []:
 -    take _ [] ++ drop _ [] = [] ++ []
 -                           = []
 -    In the inductive case:
 -    take (n+1) (x:xs) ++ drop (n+1) (x:xs)
 -            = (x: take n xs) ++ (drop n xs) \\ def's
 -            = (x: (take n xs) ++ (drop n xs)) \\ def's
 -            = (x: xs) \\ inductive hypothesis
 -
 - 6) Given the type declaration
 -    data Tree = Leaf Int | Node Tree Tree
 -    show that the number of leaves is one greater
 -    than the number of nodes
 -    SOL: Define
 -    nodes :: Tree -> Int
 -    nodes (Leaf x) = 0
 -    nodes (Node l r) = 1 + (nodes l) + (nodes r)
 -    and
 -    leaves :: Tree -> Int
 -    leaves (Leaf x) = 1
 -    leaves (Node l r) = (leaves l) + (leaves r)
 -    With these definitions, we have in the base case:
 -    leaves (Leaf _) = 1 = nodes (Leaf _) + 1
 -    Inductively, we have
 -    leaves (Node l r) = (leaves l) + (leaves r)
 -                      = (nodes l) + 1 + (nodes r) + 1
 -                      = nodes (Node l r) + 1
 -
 - 7) Verify the functor laws for Maybe
 -    SOL: We have to check that
 -    fmap id = id
 -    fmap (g . h) = fmap g . fmap h
 -    The first one is an immediate consequence of the definitions.
 -    (That is, fmap id Nothing = Nothing
 -      and fmap id (Just x) = Just (id x) = Just x)
 -    The second one is also simple, by case analysis:
 -    fmap (g . h) Nothing = Nothing
 -                         = fmap g Nothing
 -                         = fmap g (fmap h Nothing)
 -                         = (fmap g . fmap h) Nothing
 -    fmap (g . h) (Just x) = Just (g (h x))
 -                          = fmap g (Just h x)
 -                          = fmap g (fmap h (Just x))
 -                          = (fmap g . fmap h) (Just x)
 -
 - 8) Verify the functor laws for the following definition of Tree
 -    data Tree a = Leaf a | Node (Tree a) (Tree a)
 -    instance Functor Tree where
 -      -- fmap :: (a->b) -> Tree a -> Tree b
 -      fmap g (Leaf x) = Leaf (g x)
 -      fmap g (Node l r) = Node (fmap g l) (fmap g r)
 -    SOL: As above, we just need to check the two criteria.
 -    Both conditions proceed by induction. For the base cases:
 -    fmap id (Leaf x) = Leaf (id x) 
 -                     = Leaf x
 -    fmap (g . h) (Leaf x) = Leaf (g (h x))
 -                          = fmap g (Leaf h x)
 -                          = fmap g (fmap h (Leaf x))
 -                          = (fmap g . fmap h) (Leaf x)
 -    For the base case, consider a tree (Tree l r) and suppose we
 -    know the laws hold for both l and r. Then
 -    fmap id (Tree l r) = Tree (id l) (id r) \\ def
 -                       = Tree l r \\ ind. hypothesis
 -    fmap (g . h) (Tree l r) = Tree (g (h l)) (g (h r)) \\ def
 -                            = fmap g (Tree (h l) (h r)) \\ def
 -                            = fmap g (fmap h (Tree l r)) \\ def
 -                            = (fmap g . fmap h) (Tree l r)\\ def of .
 -
 - 9) Verify the applicative laws for Maybe
 -    SOL: We just go through it (these checks are always kind of a pain haha)
 -    pure id <*> Nothing = (Just id) <*> Nothing
 -                        = fmap id Nothing
 -                        = Nothing \\ def.
 -    pure id <*> (Just x) = (Just id) <*> (Just x)
 -                         = fmap id (Just x)
 -                         = Just x \\ functor laws let us skip a step
 -    --
 -    pure (g x) = Just (g x)
 -               = (Just g) <*> (Just x)
 -               = pure g <*> pure x
 -    --
 -    Nothing <*> pure y = Nothing
 -                       = fmap (ev y) Nothing \\ ev y for eval @ y
 -                       = pure (ev y) <*> Nothing
 -    (Just g) <*> pure y = fmap g (pure y)
 -                        = fmap g (Just y)
 -                        = Just (g y)
 -                        = Just (ev y g)
 -                        = fmap (ev y) (Just g)
 -                        = (Just ev y) <*> (Just g)
 -                        = pure (ev y) <*> Just g
 -    --
 -    If any of x, y, or z is Nothing, it is easy to see both sides of
 -    x <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z 
 -    evaluates to Nothing. In the other case
 -    (Just g) <*> ((Just h) <*> Just z) = (Just g) <*> fmap h (Just z)
 -                                       = (Just g) <*> Just (h z)
 -                                       = fmap g (Just h z)
 -                                       = Just (g (h z))
 -                                       = Just (g . h) <*> (Just z)
 -                                       = Just ((.) g h) <*> (Just z)
 -                                       = (Just (.) <*> Just g <*> Just h) <*> (Just z)
 -
 - 10) Verify the monad laws for the list type.
 -     SOL: Out of tedium, we only check the monad laws.
 -     The checks for functor and applicative laws are routine
 -     (though i suppose that's my job hahaha)
 -     return x >>= f = pure x >>= f
 -                    = [x] >>= f
 -                    = [y | z <- [x] , y <- f z] \\ (f z) = (f x) is a list
 -                    = [y | z <- f x]
 -                    = f x
 -     xs >>= return = [y | x <- xs, y <- return x]
 -                   = [y | x <- xs, y <- [x]]
 -                   = [y | y <- xs]
 -                   = xs
 -     (xs >>= f) >>= g = [y | x <- xs, y <- f x] >>= g
 -                      = [z | y <- A, z <- g y] \\ A = [y | x <- xs, y <- f x]
 -                      = [z | x <- xs, y <- f x, z <- g y]
 -                      = concat [[z | y <- f x, z <- g y] | x <- xs]
 -                      = xs >>= (\x -> [z | y <- f x, z <- g y])
 -                      = xs >>= (\x -> (f x >>= f))
 -
 - 11) Given the equation comp' e c = comp e ++ c,
 -     show how to construct the recursive definition for comp' on e
 -     SOL: In the base case when e = Val n, we want
 -       comp' (Val n) c = comp (Val n) ++ c
 -                       = [PUSH n] ++ c \\ def of comp
 -                       = (PUSH n : c)  \\ def of ++
 -     To get the definition in the inductive case, we want
 -       comp' (Add x y) c = comp (Add x y) ++ c
 -                         = comp x ++ comp y ++ [ADD] ++ c \\ def of comp
 -                         = comp x ++ comp y ++ (ADD : c) \\ def of ++
 -                         = comp x ++ (comp y ++ (ADD : c)) \\ assoc.
 -                         = comp x ++ (comp' y (ADD : c)) \\ recurse
 -                         = comp' x (comp' y (ADD :c)) \\ recurse
 -}
